<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Network Butcher: network_butcher::kfinder::H_g_Type&lt; T, Comparison &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Network Butcher
   </div>
   <div id="projectbrief">Just a normal butcher. A network butcher</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenetwork__butcher.html">network_butcher</a></li><li class="navelem"><a class="el" href="namespacenetwork__butcher_1_1kfinder.html">kfinder</a></li><li class="navelem"><a class="el" href="classnetwork__butcher_1_1kfinder_1_1H__g__Type.html">H_g_Type</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classnetwork__butcher_1_1kfinder_1_1H__g__Type-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">network_butcher::kfinder::H_g_Type&lt; T, Comparison &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="heap__eppstein_8h_source.html">heap_eppstein.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for network_butcher::kfinder::H_g_Type&lt; T, Comparison &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classnetwork__butcher_1_1kfinder_1_1H__g__Type__coll__graph.svg" width="227" height="264"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnetwork__butcher_1_1kfinder_1_1H__g__Type_1_1Pointer__Less.html">Pointer_Less</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple helper struct used to compare two pointers to elements of type Elem_Type.  <a href="structnetwork__butcher_1_1kfinder_1_1H__g__Type_1_1Pointer__Less.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ae5013d8d6230aac7b15f00dd33d3fa5c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetwork__butcher_1_1kfinder_1_1H__g__Type.html#ae5013d8d6230aac7b15f00dd33d3fa5c">Elem_Type</a> = <a class="el" href="classnetwork__butcher_1_1kfinder_1_1H__out__Type.html">H_out_Type</a>&lt; T, Comparison &gt;</td></tr>
<tr class="separator:ae5013d8d6230aac7b15f00dd33d3fa5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08a42659f2553361517df0a93a10cc20"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetwork__butcher_1_1kfinder_1_1H__g__Type.html#a08a42659f2553361517df0a93a10cc20">Node_Type</a> = <a class="el" href="classnetwork__butcher_1_1kfinder_1_1Heap__Node.html">Heap_Node</a>&lt; <a class="el" href="classnetwork__butcher_1_1kfinder_1_1H__g__Type.html#ae5013d8d6230aac7b15f00dd33d3fa5c">Elem_Type</a> const *, <a class="el" href="structnetwork__butcher_1_1kfinder_1_1H__g__Type_1_1Pointer__Less.html">Pointer_Less</a>, 2 &gt;</td></tr>
<tr class="memdesc:a08a42659f2553361517df0a93a10cc20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node type used to represent the nodes in the heap.  <a href="classnetwork__butcher_1_1kfinder_1_1H__g__Type.html#a08a42659f2553361517df0a93a10cc20">More...</a><br /></td></tr>
<tr class="separator:a08a42659f2553361517df0a93a10cc20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d03570f3920016fc4fc546c37765ba8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetwork__butcher_1_1kfinder_1_1H__g__Type.html#a0d03570f3920016fc4fc546c37765ba8">Internal_Collection_Type</a> = std::list&lt; <a class="el" href="classnetwork__butcher_1_1kfinder_1_1H__g__Type.html#a08a42659f2553361517df0a93a10cc20">Node_Type</a> &gt;</td></tr>
<tr class="memdesc:a0d03570f3920016fc4fc546c37765ba8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the internal collection of nodes.  <a href="classnetwork__butcher_1_1kfinder_1_1H__g__Type.html#a0d03570f3920016fc4fc546c37765ba8">More...</a><br /></td></tr>
<tr class="separator:a0d03570f3920016fc4fc546c37765ba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:adca2dbb2e67d0a7452d6b85f9a2b8278"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetwork__butcher_1_1kfinder_1_1H__g__Type.html#adca2dbb2e67d0a7452d6b85f9a2b8278">H_g_Type</a> (<a class="el" href="classnetwork__butcher_1_1kfinder_1_1H__g__Type.html#ae5013d8d6230aac7b15f00dd33d3fa5c">Elem_Type</a> const *const &amp;starting_content)</td></tr>
<tr class="separator:adca2dbb2e67d0a7452d6b85f9a2b8278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26fe7976d129d59a931b939ef3e4ce3d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetwork__butcher_1_1kfinder_1_1H__g__Type.html#a26fe7976d129d59a931b939ef3e4ce3d">H_g_Type</a> (<a class="el" href="classnetwork__butcher_1_1kfinder_1_1H__g__Type.html#ae5013d8d6230aac7b15f00dd33d3fa5c">Elem_Type</a> const *const &amp;starting_content, <a class="el" href="classnetwork__butcher_1_1kfinder_1_1H__g__Type.html">H_g_Type</a> const &amp;to_copy)</td></tr>
<tr class="separator:a26fe7976d129d59a931b939ef3e4ce3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a2a3e9f68fb7ecabd1d3e05680a6c8c"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetwork__butcher_1_1kfinder_1_1H__g__Type.html#a6a2a3e9f68fb7ecabd1d3e05680a6c8c">operator=</a> (<a class="el" href="classnetwork__butcher_1_1kfinder_1_1H__g__Type.html">H_g_Type</a> const &amp;) -&gt; <a class="el" href="classnetwork__butcher_1_1kfinder_1_1H__g__Type.html">H_g_Type</a> &amp;=delete</td></tr>
<tr class="memdesc:a6a2a3e9f68fb7ecabd1d3e05680a6c8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted copy assignment operator because the node collection is stored in a unique_ptr.  <a href="classnetwork__butcher_1_1kfinder_1_1H__g__Type.html#a6a2a3e9f68fb7ecabd1d3e05680a6c8c">More...</a><br /></td></tr>
<tr class="separator:a6a2a3e9f68fb7ecabd1d3e05680a6c8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a536e4eebdbe1d3bb8836977147ee48e1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetwork__butcher_1_1kfinder_1_1H__g__Type.html#a536e4eebdbe1d3bb8836977147ee48e1">H_g_Type</a> (<a class="el" href="classnetwork__butcher_1_1kfinder_1_1H__g__Type.html">H_g_Type</a> const &amp;)=delete</td></tr>
<tr class="memdesc:a536e4eebdbe1d3bb8836977147ee48e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted copy constructor because the node collection is stored in a unique_ptr.  <a href="classnetwork__butcher_1_1kfinder_1_1H__g__Type.html#a536e4eebdbe1d3bb8836977147ee48e1">More...</a><br /></td></tr>
<tr class="separator:a536e4eebdbe1d3bb8836977147ee48e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad326810949d744b80705a892d404df43"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetwork__butcher_1_1kfinder_1_1H__g__Type.html#ad326810949d744b80705a892d404df43">operator=</a> (<a class="el" href="classnetwork__butcher_1_1kfinder_1_1H__g__Type.html">H_g_Type</a> &amp;&amp;) noexcept -&gt; <a class="el" href="classnetwork__butcher_1_1kfinder_1_1H__g__Type.html">H_g_Type</a> &amp;=default</td></tr>
<tr class="memdesc:ad326810949d744b80705a892d404df43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default move assignment operator.  <a href="classnetwork__butcher_1_1kfinder_1_1H__g__Type.html#ad326810949d744b80705a892d404df43">More...</a><br /></td></tr>
<tr class="separator:ad326810949d744b80705a892d404df43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa922fcc3ef6248966b127dd39a3487f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetwork__butcher_1_1kfinder_1_1H__g__Type.html#aaa922fcc3ef6248966b127dd39a3487f">H_g_Type</a> (<a class="el" href="classnetwork__butcher_1_1kfinder_1_1H__g__Type.html">H_g_Type</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="memdesc:aaa922fcc3ef6248966b127dd39a3487f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default move constructor.  <a href="classnetwork__butcher_1_1kfinder_1_1H__g__Type.html#aaa922fcc3ef6248966b127dd39a3487f">More...</a><br /></td></tr>
<tr class="separator:aaa922fcc3ef6248966b127dd39a3487f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ae91fcd3205a11cb07ef10252d64ad9"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetwork__butcher_1_1kfinder_1_1H__g__Type.html#a1ae91fcd3205a11cb07ef10252d64ad9">get_head_node</a> () const -&gt; <a class="el" href="classnetwork__butcher_1_1kfinder_1_1H__g__Type.html#a08a42659f2553361517df0a93a10cc20">Node_Type</a> const *</td></tr>
<tr class="separator:a1ae91fcd3205a11cb07ef10252d64ad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ef4a0d444879fa201219dc6f31d315c"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetwork__butcher_1_1kfinder_1_1H__g__Type.html#a8ef4a0d444879fa201219dc6f31d315c">size</a> () const -&gt; std::size_t</td></tr>
<tr class="separator:a8ef4a0d444879fa201219dc6f31d315c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9af413fb2d72ba32e611829a2731cfff"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetwork__butcher_1_1kfinder_1_1H__g__Type.html#a9af413fb2d72ba32e611829a2731cfff">empty</a> () const -&gt; bool</td></tr>
<tr class="separator:a9af413fb2d72ba32e611829a2731cfff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f01ae4662ea7fa2a7408ac67c4a0a6c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetwork__butcher_1_1kfinder_1_1H__g__Type.html#a9f01ae4662ea7fa2a7408ac67c4a0a6c">~H_g_Type</a> ()=default</td></tr>
<tr class="separator:a9f01ae4662ea7fa2a7408ac67c4a0a6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:aa74b5a3004cb5160fe1575ad8fa25156"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetwork__butcher_1_1kfinder_1_1H__g__Type.html#aa74b5a3004cb5160fe1575ad8fa25156">construction_from_other_h_g</a> (<a class="el" href="classnetwork__butcher_1_1kfinder_1_1Heap__Node.html#ab3ab660d3468988056f112ade304f648">Node_Type::Content_Type</a> const &amp;starting_content, <a class="el" href="classnetwork__butcher_1_1kfinder_1_1H__g__Type.html#a08a42659f2553361517df0a93a10cc20">Node_Type</a> const *other_h_g, <a class="el" href="classnetwork__butcher_1_1kfinder_1_1H__g__Type.html#a08a42659f2553361517df0a93a10cc20">Node_Type</a> *parent)</td></tr>
<tr class="separator:aa74b5a3004cb5160fe1575ad8fa25156"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a7fb34ac5acb5a1c9e9a8bccf5d0eb941"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classnetwork__butcher_1_1kfinder_1_1H__g__Type.html#a0d03570f3920016fc4fc546c37765ba8">Internal_Collection_Type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetwork__butcher_1_1kfinder_1_1H__g__Type.html#a7fb34ac5acb5a1c9e9a8bccf5d0eb941">internal_children</a></td></tr>
<tr class="memdesc:a7fb34ac5acb5a1c9e9a8bccf5d0eb941"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal collection of nodes.  <a href="classnetwork__butcher_1_1kfinder_1_1H__g__Type.html#a7fb34ac5acb5a1c9e9a8bccf5d0eb941">More...</a><br /></td></tr>
<tr class="separator:a7fb34ac5acb5a1c9e9a8bccf5d0eb941"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, typename Comparison&gt;<br />
class network_butcher::kfinder::H_g_Type&lt; T, Comparison &gt;</h3>

<p>Simple class used to represent an H_g, an heap of H_out. During its construction, several children of nodes contained in the heap do not point to nodes that are "physically" stored in the heap itself, but instead point to nodes that are stored in different H_g heaps. This is done to avoid the need to copy the entire H_g structure when it's not needed. Moreover, notice that this class does not implement a proper binary heap, since we will give priority during the insertion to the branches that have the least number of children. Thus, we lose the array representation of the heap, but, in this way, we both save memory and we can still navigate the heap through pointers. This class will still be a valid min-heap (but not a proper binary min-heap). </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type stored inside each H_out </td></tr>
    <tr><td class="paramname">Comparison</td><td>The comparison function used to compare two elements of type T </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ae5013d8d6230aac7b15f00dd33d3fa5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5013d8d6230aac7b15f00dd33d3fa5c">&#9670;&nbsp;</a></span>Elem_Type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Comparison &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classnetwork__butcher_1_1kfinder_1_1H__g__Type.html">network_butcher::kfinder::H_g_Type</a>&lt; T, Comparison &gt;::<a class="el" href="classnetwork__butcher_1_1kfinder_1_1H__g__Type.html#ae5013d8d6230aac7b15f00dd33d3fa5c">Elem_Type</a> =  <a class="el" href="classnetwork__butcher_1_1kfinder_1_1H__out__Type.html">H_out_Type</a>&lt;T, Comparison&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0d03570f3920016fc4fc546c37765ba8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d03570f3920016fc4fc546c37765ba8">&#9670;&nbsp;</a></span>Internal_Collection_Type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Comparison &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classnetwork__butcher_1_1kfinder_1_1H__g__Type.html">network_butcher::kfinder::H_g_Type</a>&lt; T, Comparison &gt;::<a class="el" href="classnetwork__butcher_1_1kfinder_1_1H__g__Type.html#a0d03570f3920016fc4fc546c37765ba8">Internal_Collection_Type</a> =  std::list&lt;<a class="el" href="classnetwork__butcher_1_1kfinder_1_1H__g__Type.html#a08a42659f2553361517df0a93a10cc20">Node_Type</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of the internal collection of nodes. </p>

</div>
</div>
<a id="a08a42659f2553361517df0a93a10cc20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08a42659f2553361517df0a93a10cc20">&#9670;&nbsp;</a></span>Node_Type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Comparison &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classnetwork__butcher_1_1kfinder_1_1H__g__Type.html">network_butcher::kfinder::H_g_Type</a>&lt; T, Comparison &gt;::<a class="el" href="classnetwork__butcher_1_1kfinder_1_1H__g__Type.html#a08a42659f2553361517df0a93a10cc20">Node_Type</a> =  <a class="el" href="classnetwork__butcher_1_1kfinder_1_1Heap__Node.html">Heap_Node</a>&lt;<a class="el" href="classnetwork__butcher_1_1kfinder_1_1H__g__Type.html#ae5013d8d6230aac7b15f00dd33d3fa5c">Elem_Type</a> const *, <a class="el" href="structnetwork__butcher_1_1kfinder_1_1H__g__Type_1_1Pointer__Less.html">Pointer_Less</a>, 2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Node type used to represent the nodes in the heap. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="adca2dbb2e67d0a7452d6b85f9a2b8278"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adca2dbb2e67d0a7452d6b85f9a2b8278">&#9670;&nbsp;</a></span>H_g_Type() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Comparison &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnetwork__butcher_1_1kfinder_1_1H__g__Type.html">network_butcher::kfinder::H_g_Type</a>&lt; T, Comparison &gt;::<a class="el" href="classnetwork__butcher_1_1kfinder_1_1H__g__Type.html">H_g_Type</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnetwork__butcher_1_1kfinder_1_1H__g__Type.html#ae5013d8d6230aac7b15f00dd33d3fa5c">Elem_Type</a> const *const &amp;&#160;</td>
          <td class="paramname"><em>starting_content</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>It will construct H_g from the given H_out </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">starting_content</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a26fe7976d129d59a931b939ef3e4ce3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26fe7976d129d59a931b939ef3e4ce3d">&#9670;&nbsp;</a></span>H_g_Type() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Comparison &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnetwork__butcher_1_1kfinder_1_1H__g__Type.html">network_butcher::kfinder::H_g_Type</a>&lt; T, Comparison &gt;::<a class="el" href="classnetwork__butcher_1_1kfinder_1_1H__g__Type.html">H_g_Type</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnetwork__butcher_1_1kfinder_1_1H__g__Type.html#ae5013d8d6230aac7b15f00dd33d3fa5c">Elem_Type</a> const *const &amp;&#160;</td>
          <td class="paramname"><em>starting_content</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnetwork__butcher_1_1kfinder_1_1H__g__Type.html">H_g_Type</a>&lt; T, Comparison &gt; const &amp;&#160;</td>
          <td class="paramname"><em>to_copy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>It will construct H_g from the given H_out and H_g. Pointers to the nodes in the provided H_g will be used to build the new H_g </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">starting_content</td><td>The H_out to use to build the new H_g </td></tr>
    <tr><td class="paramname">to_copy</td><td>The H_g to use to build the new H_g </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a536e4eebdbe1d3bb8836977147ee48e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a536e4eebdbe1d3bb8836977147ee48e1">&#9670;&nbsp;</a></span>H_g_Type() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Comparison &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnetwork__butcher_1_1kfinder_1_1H__g__Type.html">network_butcher::kfinder::H_g_Type</a>&lt; T, Comparison &gt;::<a class="el" href="classnetwork__butcher_1_1kfinder_1_1H__g__Type.html">H_g_Type</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnetwork__butcher_1_1kfinder_1_1H__g__Type.html">H_g_Type</a>&lt; T, Comparison &gt; const &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deleted copy constructor because the node collection is stored in a unique_ptr. </p>

</div>
</div>
<a id="aaa922fcc3ef6248966b127dd39a3487f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa922fcc3ef6248966b127dd39a3487f">&#9670;&nbsp;</a></span>H_g_Type() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Comparison &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnetwork__butcher_1_1kfinder_1_1H__g__Type.html">network_butcher::kfinder::H_g_Type</a>&lt; T, Comparison &gt;::<a class="el" href="classnetwork__butcher_1_1kfinder_1_1H__g__Type.html">H_g_Type</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnetwork__butcher_1_1kfinder_1_1H__g__Type.html">H_g_Type</a>&lt; T, Comparison &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default move constructor. </p>

</div>
</div>
<a id="a9f01ae4662ea7fa2a7408ac67c4a0a6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f01ae4662ea7fa2a7408ac67c4a0a6c">&#9670;&nbsp;</a></span>~H_g_Type()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Comparison &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnetwork__butcher_1_1kfinder_1_1H__g__Type.html">network_butcher::kfinder::H_g_Type</a>&lt; T, Comparison &gt;::~<a class="el" href="classnetwork__butcher_1_1kfinder_1_1H__g__Type.html">H_g_Type</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa74b5a3004cb5160fe1575ad8fa25156"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa74b5a3004cb5160fe1575ad8fa25156">&#9670;&nbsp;</a></span>construction_from_other_h_g()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Comparison &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classnetwork__butcher_1_1kfinder_1_1H__g__Type.html">network_butcher::kfinder::H_g_Type</a>&lt; T, Comparison &gt;::construction_from_other_h_g </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnetwork__butcher_1_1kfinder_1_1Heap__Node.html#ab3ab660d3468988056f112ade304f648">Node_Type::Content_Type</a> const &amp;&#160;</td>
          <td class="paramname"><em>starting_content</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnetwork__butcher_1_1kfinder_1_1H__g__Type.html#a08a42659f2553361517df0a93a10cc20">Node_Type</a> const *&#160;</td>
          <td class="paramname"><em>other_h_g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnetwork__butcher_1_1kfinder_1_1H__g__Type.html#a08a42659f2553361517df0a93a10cc20">Node_Type</a> *&#160;</td>
          <td class="paramname"><em>parent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Helper (recursive) function to construct the new H_g from the given H_out and H_g </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">starting_content</td><td>The initial H_out </td></tr>
    <tr><td class="paramname">other_h_g</td><td>A node of the H_g used to build the new H_g </td></tr>
    <tr><td class="paramname">parent</td><td>The parent of the current heap </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9af413fb2d72ba32e611829a2731cfff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9af413fb2d72ba32e611829a2731cfff">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Comparison &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classnetwork__butcher_1_1kfinder_1_1H__g__Type.html">network_butcher::kfinder::H_g_Type</a>&lt; T, Comparison &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bool
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>It will return true if the heap is empty, false otherwise </p><dl class="section return"><dt>Returns</dt><dd>True if the heap is empty, false otherwise </dd></dl>

</div>
</div>
<a id="a1ae91fcd3205a11cb07ef10252d64ad9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ae91fcd3205a11cb07ef10252d64ad9">&#9670;&nbsp;</a></span>get_head_node()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Comparison &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classnetwork__butcher_1_1kfinder_1_1H__g__Type.html">network_butcher::kfinder::H_g_Type</a>&lt; T, Comparison &gt;::get_head_node </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classnetwork__butcher_1_1kfinder_1_1H__g__Type.html#a08a42659f2553361517df0a93a10cc20">Node_Type</a> const *
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>It will return the head node of the heap </p><dl class="section return"><dt>Returns</dt><dd>The head node of the heap (as a pointer to a constant node) </dd></dl>

</div>
</div>
<a id="ad326810949d744b80705a892d404df43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad326810949d744b80705a892d404df43">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Comparison &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classnetwork__butcher_1_1kfinder_1_1H__g__Type.html">network_butcher::kfinder::H_g_Type</a>&lt; T, Comparison &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnetwork__butcher_1_1kfinder_1_1H__g__Type.html">H_g_Type</a>&lt; T, Comparison &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  <a class="el" href="classnetwork__butcher_1_1kfinder_1_1H__g__Type.html">H_g_Type</a> &amp;=default</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default move assignment operator. </p>

</div>
</div>
<a id="a6a2a3e9f68fb7ecabd1d3e05680a6c8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a2a3e9f68fb7ecabd1d3e05680a6c8c">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Comparison &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classnetwork__butcher_1_1kfinder_1_1H__g__Type.html">network_butcher::kfinder::H_g_Type</a>&lt; T, Comparison &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnetwork__butcher_1_1kfinder_1_1H__g__Type.html">H_g_Type</a>&lt; T, Comparison &gt; const &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  <a class="el" href="classnetwork__butcher_1_1kfinder_1_1H__g__Type.html">H_g_Type</a> &amp;=delete</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deleted copy assignment operator because the node collection is stored in a unique_ptr. </p>

</div>
</div>
<a id="a8ef4a0d444879fa201219dc6f31d315c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ef4a0d444879fa201219dc6f31d315c">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Comparison &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classnetwork__butcher_1_1kfinder_1_1H__g__Type.html">network_butcher::kfinder::H_g_Type</a>&lt; T, Comparison &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; std::size_t
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>It will return the size of the heap </p><dl class="section return"><dt>Returns</dt><dd>The size of the heap </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a7fb34ac5acb5a1c9e9a8bccf5d0eb941"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fb34ac5acb5a1c9e9a8bccf5d0eb941">&#9670;&nbsp;</a></span>internal_children</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Comparison &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classnetwork__butcher_1_1kfinder_1_1H__g__Type.html#a0d03570f3920016fc4fc546c37765ba8">Internal_Collection_Type</a>&gt; <a class="el" href="classnetwork__butcher_1_1kfinder_1_1H__g__Type.html">network_butcher::kfinder::H_g_Type</a>&lt; T, Comparison &gt;::internal_children</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal collection of nodes. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/K-shortest_path/<a class="el" href="heap__eppstein_8h_source.html">heap_eppstein.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
