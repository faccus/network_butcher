\section{Data Structures}

\begin{frame}[plain]{}
    \sectionpage
\end{frame}

\begin{frame}{Type\_info and Dense\_tensor}
    \begin{block} {Type\_info}
    A pure virtual class used to store a onnx::ValueProto (that is, to store an input, output or parameter of the NN)
    \end{block}
    
    \begin{block}{Dense\_tensor}
    A specialization of Type\_info used to store a onnx::DenseTensor or a onnx::SparseTensor
    \end{block}
    
    Since we are only interested in the type of the elements, shape of the tensor and whether the tensor it's a parameter or not, no other information is stored
\end{frame}

\begin{frame}{Content$<$T$>$}
    Content is a generic class used to represent the content of a single node in the NN. The main members are:
    
    \begin{itemize}
        \item input, output and parameters: three maps that associate to a std::string an object of type T. In practice, T is a std::shared\_ptr$<$Type\_info$>$
        \item attributes: a map that associates to every attribute name a vector of DynamicType, a custom type used to store either a vector of floats or unsigned long ints
    \end{itemize}
    
\end{frame}


\begin{frame}[allowframebreaks]{Node$<$T$>$ and Graph$<$T$>$}
    \begin{block}{Node$<$T$>$}
    Node$<$T$>$ is a simple class used to represent a node in a graph. To every node is associated a content of type T and an id.
    \end{block}
    
    \begin{block}{Graph$<$T$>$}
    Graph$<$T$>$ is used to represent a graph made by Node$<$T$>$.
    \end{block}
    
    \framebreak
    
    The main members of Graph$<$T$>$ are:
    \begin{itemize}
        \item nodes: a std::vector$<$Node$<$T$>>$
        \item dependencies: a vector that contains for every node the set of input and output node ids for the given node (the id of the node is equal to its position in the nodes vector)
        \item remove\_nodes: a method used to remove a set of nodes from the graph
    \end{itemize}
    Graph$<$T$>$ is specialized in the case T=Content$<$S$>$ where S is another template variable. In this case, an extra member function is present: compute\_dependencies, a function used to compute the dependencies vector for the graph by analyzing the input and output field of every node: if a node i has in the output map an object with the same name as an object of the input map of a second node j, then a link $($i,j$)$ is formed (and the dependencies vector is adjusted accordingly).
\end{frame}

\begin{frame}{MWGraph$<$T$>$ and WGraph$<$T$>$}
    \begin{alertblock}{MWGraph$<$T$>$}
    MWGraph$<$T$>$ is a derived class from Graph$<$T$>$, that only adds a std::vector of weights\_collection\_type (a simple map from a pair of node ids to a weight) and related getter and setters for the different weights in the different maps. 
    \end{alertblock}
    
    Every weight map is associated to a different device, a computing resources onto which a part of the NN may be executed
    
    \begin{block}{WGraph$<$T$>$}
    WGraph$<$T$>$ is a derived class from MWGraph$<$T$>$ that implements the specific case of weighted graphs with a single device (basically, a classical directed weighted graph).
    \end{block}
    
    
\end{frame}