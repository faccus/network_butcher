# Network Butcher
The objective of this project is to develop a C++20 library that can find, given a Deep Neural 
Network in Onnx format, the K optimal ways of partitioning it in order to minimize the overall execution time of the 
model itself on multiple devices.
Currently, the library can only be compiled as a static library.

The documentation can be manually generated by using Doxygen (as presented below) or by accessing 
it through [GitHub Pages](https://faccus.github.io/network_butcher/).

### Project structure

The project is structured into four main directories:

- include/network_butcher: It contains all the header files of the library. 
  A [README](include/network_butcher/README.md) file describing its contents is also available.
- src: It contains all the source files of the library. 
  Moreover, in the CMakeList file, all the external libraries used by the library are imported (except GoogleTest and
  Doxygen). 
  A [README](src/README.md) file describing its contents is also available.
- google_tests: It contains all the source files of the tests.
  Each source file contains a brief description of the purposes of the associated test suit, while, before each test,
  a small comment on its purpose is present.
- mains: It contains both a collection of main files to test the performances of the program and the basic main file
  that allows to perform the partitioning directly from command-line.
  A [README](mains/README.md) file describing its contents is also available.

The other directories are:

- dep: It contains the external libraries (currently, only aMLLibrary). They are stored as submodules.
- doc: It contains the CMakeLists.txt file with the options used to generate the documentation
- scripts: It contains some extra scripts to modify an .onnx file to add shapes to all the tensors (it must be executed
  for a new .onnx model, unless shapes were already inferred).
  Moreover, the notebooks used to create the plots of the measured performances are also present (as well as the actual
  results)
- test_data: It contains the files used during testing (models, sample configuration files and sample weight files).
  A [README](test_data/README.md) file describing its contents is also available.

To easily start reading the project, we think it's best to start from the general_manager.h header file.

### Requirements:
- CMake version 3.21 (or higher). Required to configure and compile the code. Must be installed by the user
- g++ version 8 (or higher). Required to compile the code. Must be installed the user
- [Protobuf v3.21.12](https://github.com/protocolbuffers/protobuf/tree/v21.12) (Required). 
  This library may be manually installed and linked against our library by checking the appropriate option in the 
  CMakeLists.txt file 
- [Google Tests v1.12.1](https://github.com/google/googletest/releases/tag/release-1.12.1) (Optional). 
It is automatically downloaded by CMake if tests are enabled in the CMakeLists.txt file
- [Doxygen v1.9.3 or higher](https://github.com/doxygen/doxygen/releases/tag/Release_1_9_3) (Optional). 
It must be manually installed (with its dependencies: Graphviz, dia and mscgen)

The weight generation may be automatically performed if a compatible model is provided. 
This, however, adds some extra requirements:

- [PyBind v2.10.3](https://github.com/pybind/pybind11/releases/tag/v2.10.3).
  The library will be automatically downloaded and compiled by CMake. 
  However, it requires Python3 and pip to be installed.
- [aMLLibrary](https://github.com/brunoguindani/aMLLibrary/tree/933be8b094ca468d4813fe0c837fc6d46cc608d2) (Python github
  project). 
  A local version of the package is already available (as a submodule) in the dep directory. 
  Since the package is still work in progress, we chose a specific commit.
  For an explanation on why it is employed and a quick tutorial on its usage, please refer to the 
  [README](test_data/aMLLibrary_data/README.md) file.
  To install all of its package dependencies, simply call in our repository root directory:
```bash
python3 -m pip install -r dep/aMLLibrary/requirements.txt
```
- [Onnx-Tool v0.6.1](https://github.com/ThanatosShinji/onnx-tool) (Python Package). To install it, simply call:
```bash
python3 -m pip install onnx-tool==0.6.1
```

The CMakeLists.txt file exposes some options that may be changed to avoid the usage of some of the previously cited
libraries.

Parallelism can be enabled by checking the proper option in the CMakeLists.txt file. 
Parallelism may be used with either:

- [OpenMP v4.5](https://www.openmp.org/). 
  Since we do not fix the number of parallel threads that the library can use directly in the code, we advise setting 
  the environment variable OMP_NUM_THREADS to the desired number of threads.
- [Intel TBB v2021.5.0](https://www.intel.com/content/www/us/en/developer/tools/oneapi/onetbb.html). 
In particular, this library is used to allow parallelism through the 'execution' standard library header file.
In this case, the number of threads can only be fixed manually in the code. 
By default, it will run using the maximum number of threads.

We advise, if undecided on which library to use, to employ OpenMP, since it is easier to install and use.

### Requirements Quick Install (Linux only)
We here report a small collection of simple bash commands to install the required libraries on a Linux system:
- Compiler, CMake and Doxygen (with its extra packages):
```bash
sudo apt-get update && sudo apt-get install build-essential cmake doxygen graphviz dia mscgen -y
```
- Python, pip, aMLLibrary requirements and onnx-tool:
```bash
sudo apt-get install python3-dev python3-pip --no-install-recommends -y
```
```bash
python3 -m pip install -r dep/aMLLibrary/requirements.txt
```
```bash
python3 -m pip install onnx-tool==0.6.1
```
- OpenMP and TBB:
```bash
sudo apt-get install libomp-14-dev libtbb-dev -y
```

### Docker
A Dockerfile is available to speed up the initial setup.
The file contains all the required dependencies to run each component of the library.

To build the image, after having cloned the project, simply run from the project directory:
```bash
docker build -t network_butcher .
```

To run the container and enter the bash shell, run:
```bash
docker run --name nn --rm -v $(pwd):/network_butcher -it network_butcher
```

### Project setup:

1. Clone the repository:

```bash
git clone https://github.com/faccus/network_butcher --recurse-submodules
```

or

```bash
git clone git@github.com:faccus/network_butcher.git --recurse-submodules
```

2. Create the build directory and move there:

```bash
cd network_butcher
mkdir build
cd build
```

3. Prepare the directory for the build:
```bash
cmake -DCMAKE_BUILD_TYPE=Release -S .. -B . -DBUILD_PROTOBUF_SOURCE=ON -DUSE_GOOGLETEST=ON -DDISCOVER_COMPLETE_TESTS=ON -DENABLE_NETWORK_BUTCHER_PARALLEL=OFF -DUSE_OPENMP=ON -DUSE_PYBIND=OFF -DBUILD_DOC=OFF
```
You can customize the command by changing to ON/OFF the various options.
If you prefer to edit manually the file, you can edit the options in the CMakeLists.txt file in the root directory of 
the repository and, then, call, in the build directory:
```bash
cmake -DCMAKE_BUILD_TYPE=Release -S .. -B . 
```
Notice that, during this phase, if USE_PYBIND=ON, CMake will create a header file in the src directory (of the build), 
in order to have the path to the aMLLibrary package.

#### Build Options
Once the directory is prepared for the build, you can request CMake to compile several possible targets, detailed in the
next subsections.
The general procedure to compile any target is simple, since you just need to call:
```bash
cmake --build . --target TARGET_TO_COMPILE
```

#### network_butcher
If network_butcher is chosen as the target, CMake will compile and output in the src directory of the build the (static) 
library

#### main
If main is chosen as the target, CMake will compile network_butcher and, using the main.cpp file contained in mains,
it will generate a simple executable, called main: it will read from the command line the path to a configuration file
(sample configuration files are reported in test_data/configs) and perform the partitioning of the provided model.
A help message will be printed if the command is not recognized.

```bash
./main config_file=path/to/config
```

#### Profiling mains

To properly verify the performances of the associated library, we decided to make available a collection of main files
to properly measure the time required to perform each phase of the "butchering".
They can be easily compiled by calling in the configured build directory:

```bash
cmake --build . --target main_Constrained_Builder
cmake --build . --target main_IO_Manager
cmake --build . --target main_kfinder
cmake --build . --target main_path_reconstruction
cmake --build . --target main_synthetic_graph
```

For more details on what do they do, check the following [README](mains/README.md) file.

#### Doxygen
To run doxygen and generate the documentation, you can just call from the build directory:
```bash
cmake --build . --target doxygen
```


#### Tests

Optionally, if the appropriate option was chosen during the initial configuration, the tests can be built by using the 
following command:
```bash
cmake --build . --target test_run
```

and executed by:

```bash
./test_run
```

By changing the target to 'test_run_complete' a longer collection of tests will be executed.
This is useful to check the correctness of the program, but it may take a while to complete.
